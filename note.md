## 为什么学习`TypeScript`

获得更好的开发体验

解决`JS`中一些难以处理的问题

### `JS`开发中的问题

使用了不存在的变量、函数或成员

把一个不确定的类型当作一个确定的类型处理

在使用null或undefined的成员

### `JS`的缺点

`js`语言本身的特性，决定了该语言不能适应大型的复杂的项目

弱类型：某个变量，可以随时更换类型

解释性：错误发生时间，是运行时才报错

## `TypeScript`

`TypeScript`是`JS`的超集，是一个可选的、静态的类型系统。

### 类型系统

对代码中所有的标识符（变量、函数、参数、返回值）进行类型检查。

### 可选的

类型检查可用可不用

### 静态的

无论是浏览器环境，还是node环境，无法直接识别ts代码。

静态：类型检查发生在编译的时候，而发运行

ts不参与任何运行时的类型检查

### 额外惊喜

有了类型检查，可以增强面向对象的开发。

`js`中也有类和对象，支持面向对象开发。没有类型检查，很多面向对象的场景实现起来存在诸多问题。

### 使用TS后，可以编写处完善的面向对象代码。

## TS的使用（版本4.2.4）

```typescript
let myName:string = 'yang'
```

会提示name变量已经存在

默认情况下，TS会做出下面几种假设：

- 假设当前的执行环境为浏览器环境

- 如果代码中没有使用模块化语句（import、export），便认为代码是全局执行

- 编译的目标代码是`ES3`

  ```javascript
  var myName = 'yang';
  ```

有两种方式改变以上假设：

1. 使用`tsc`命令行的时候，加上选项参数
2. 使用ts配置文件，更改编译选项

### typescript配置文件

1. 可以新建一个`tsconfig.json`文件
2. 使用`tsc --init`命令生产配置文件

```json
{
  "compilerOptions": { // 编译选项
    "target": "ES2016", // 配置编译目标代码的版本标准
    "module": "commonjs", // 配置编译目标的模块化标准  
    "lib": ["es2016"], // 环境变量
    "outDir": "./dist" // 编译结果
  },
  "include": ["./src"] // 编译目录
}
```

使用了配置文件后，使用`tsc`进行编译时，不能跟上文件名，如果跟上文件名，会忽略配置文件。

### 第三方库简化流程

`ts-node`：`ts-node` + 文件路径 ，将ts代码在内存中完成编译，同时完成运行。

`nodemon`: 用于监测文件变化